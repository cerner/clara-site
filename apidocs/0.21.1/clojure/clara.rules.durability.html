<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>clara.rules.durability documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Clara-rules</span> <span class="project-version">0.21.1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clara</span></div></div></li><li class="depth-2"><a href="clara.rules.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rules</span></div></a></li><li class="depth-3 branch"><a href="clara.rules.accumulators.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>accumulators</span></div></a></li><li class="depth-3 branch"><a href="clara.rules.dsl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dsl</span></div></a></li><li class="depth-3 branch current"><a href="clara.rules.durability.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>durability</span></div></a></li><li class="depth-3"><a href="clara.rules.listener.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>listener</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>tools</span></div></div></li><li class="depth-3 branch"><a href="clara.tools.fact-graph.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fact-graph</span></div></a></li><li class="depth-3 branch"><a href="clara.tools.inspect.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>inspect</span></div></a></li><li class="depth-3"><a href="clara.tools.tracing.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tracing</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="clara.rules.durability.html#var-add-accumulator"><div class="inner"><span>add-accumulator</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-add-alpha-fn"><div class="inner"><span>add-alpha-fn</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-add-join-filter-fn"><div class="inner"><span>add-join-filter-fn</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-add-rhs-fn"><div class="inner"><span>add-rhs-fn</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-add-test-fn"><div class="inner"><span>add-test-fn</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-assemble-restored-session"><div class="inner"><span>assemble-restored-session</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-cache-node"><div class="inner"><span>cache-node</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-clj-struct-.3Eidx"><div class="inner"><span>clj-struct-&gt;idx</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-clj-struct-holder"><div class="inner"><span>clj-struct-holder</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-clj-struct-holder-add-fact-idx.21"><div class="inner"><span>clj-struct-holder-add-fact-idx!</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-clj-struct-holder-add-obj.21"><div class="inner"><span>clj-struct-holder-add-obj!</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-clj-struct-idx-.3Eobj"><div class="inner"><span>clj-struct-idx-&gt;obj</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-create-map-entry"><div class="inner"><span>create-map-entry</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-deserialize-rulebase"><div class="inner"><span>deserialize-rulebase</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-deserialize-session-state"><div class="inner"><span>deserialize-session-state</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-find-index"><div class="inner"><span>find-index</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-find-internal-idx"><div class="inner"><span>find-internal-idx</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-find-mem-idx"><div class="inner"><span>find-mem-idx</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-index-accum-memory"><div class="inner"><span>index-accum-memory</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-index-activation-map"><div class="inner"><span>index-activation-map</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-index-alpha-memory"><div class="inner"><span>index-alpha-memory</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-index-beta-memory"><div class="inner"><span>index-beta-memory</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-index-production-memory"><div class="inner"><span>index-production-memory</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-indexed-session-memory-state"><div class="inner"><span>indexed-session-memory-state</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-ISessionSerializer"><div class="inner"><span>ISessionSerializer</span></div></a></li><li class="depth-2 branch"><a href="clara.rules.durability.html#var-deserialize"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>deserialize</span></div></a></li><li class="depth-2"><a href="clara.rules.durability.html#var-serialize"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>serialize</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-IWorkingMemorySerializer"><div class="inner"><span>IWorkingMemorySerializer</span></div></a></li><li class="depth-2 branch"><a href="clara.rules.durability.html#var-deserialize-facts"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>deserialize-facts</span></div></a></li><li class="depth-2"><a href="clara.rules.durability.html#var-serialize-facts"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>serialize-facts</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-mem-facts"><div class="inner"><span>mem-facts</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-mem-internal"><div class="inner"><span>mem-internal</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-node-fn-cache"><div class="inner"><span>node-fn-cache</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-node-id-.3Enode"><div class="inner"><span>node-id-&gt;node</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-node-id-.3Enode-cache"><div class="inner"><span>node-id-&gt;node-cache</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-opts-.3Eget-alphas-fn"><div class="inner"><span>opts-&gt;get-alphas-fn</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-rulebase-.3Erulebase-with-opts"><div class="inner"><span>rulebase-&gt;rulebase-with-opts</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-seq-.3Esorted-map"><div class="inner"><span>seq-&gt;sorted-map</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-seq-.3Esorted-set"><div class="inner"><span>seq-&gt;sorted-set</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-serialize-rulebase"><div class="inner"><span>serialize-rulebase</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-serialize-session-state"><div class="inner"><span>serialize-session-state</span></div></a></li><li class="depth-1"><a href="clara.rules.durability.html#var-sorted-comparator-name"><div class="inner"><span>sorted-comparator-name</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">clara.rules.durability</h1><div class="doc"><div class="markdown"><p>Support for persisting Clara sessions to an external store. Provides the ability to store and restore an entire session working memory state. The restored session is able to have additional insert, retract, query, and fire rule calls performed immediately after.</p>
<p>See <a href="https://github.com/cerner/clara-rules/issues/198">https://github.com/cerner/clara-rules/issues/198</a> for more discussion on this.</p>
<p>Note! This is still an EXPERIMENTAL namespace. This may change non-passively without warning. Any session or rulebase serialized in one version of Clara is not guaranteed to deserialize successfully against another version of Clara.</p></div></div><div class="public anchor" id="var-add-accumulator"><h3>add-accumulator</h3><div class="usage"><code>(add-accumulator node)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-add-alpha-fn"><h3>add-alpha-fn</h3><div class="usage"><code>(add-alpha-fn node)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-add-join-filter-fn"><h3>add-join-filter-fn</h3><div class="usage"><code>(add-join-filter-fn node)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-add-rhs-fn"><h3>add-rhs-fn</h3><div class="usage"><code>(add-rhs-fn node)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-add-test-fn"><h3>add-test-fn</h3><div class="usage"><code>(add-test-fn node)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-assemble-restored-session"><h3>assemble-restored-session</h3><div class="usage"><code>(assemble-restored-session rulebase opts)</code><code>(assemble-restored-session rulebase memory opts)</code></div><div class="doc"><div class="markdown"><p>Builds a Clara session from the given rulebase and memory components. When no memory is given a new one is created with all of the defaults of eng/local-memory. Note! This function should not typically be used. It is left public to assist in ISessionSerializer  durability implementations. Use clara.rules/mk-session typically to make rule sessions.</p>
<p>If the options are not provided, they will default to the Clara session defaults. The available options on the session (as opposed to the rulebase) are the transport and listeners.</p>
<p>Note! Currently this only supports the clara.rules.memory.PersistentLocalMemory implementation  of memory.</p></div></div></div><div class="public anchor" id="var-cache-node"><h3>cache-node</h3><div class="usage"><code>(cache-node node)</code></div><div class="doc"><div class="markdown"><p>Cache the node in the node-id-&gt;node-cache. Returns the node.</p></div></div></div><div class="public anchor" id="var-clj-struct-.3Eidx"><h3>clj-struct-&gt;idx</h3><div class="usage"><code>(clj-struct-&gt;idx fact)</code></div><div class="doc"><div class="markdown"><p>Gets the numeric index for the given struct from the clj-struct-holder.</p></div></div></div><div class="public anchor" id="var-clj-struct-holder"><h3>clj-struct-holder</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A cache for writing and reading Clojure records. At write time, an IdentityHashMap can be used to keep track of repeated references to the same object instance occurring in the serialization stream. At read time, a plain ArrayList (mutable and indexed for speed) can be used to add records to when they are first seen, then look up repeated occurrences of references to the same record instance later.</p></div></div></div><div class="public anchor" id="var-clj-struct-holder-add-fact-idx.21"><h3>clj-struct-holder-add-fact-idx!</h3><div class="usage"><code>(clj-struct-holder-add-fact-idx! fact)</code></div><div class="doc"><div class="markdown"><p>Adds the fact to the clj-struct-holder with a new index. This can later be retrieved with clj-struct-&gt;idx.</p></div></div></div><div class="public anchor" id="var-clj-struct-holder-add-obj.21"><h3>clj-struct-holder-add-obj!</h3><div class="usage"><code>(clj-struct-holder-add-obj! fact)</code></div><div class="doc"><div class="markdown"><p>The reverse of clj-struct-holder-add-fact-idx!. Adds the object to the clj-struct-holder at the next available index.</p></div></div></div><div class="public anchor" id="var-clj-struct-idx-.3Eobj"><h3>clj-struct-idx-&gt;obj</h3><div class="usage"><code>(clj-struct-idx-&gt;obj id)</code></div><div class="doc"><div class="markdown"><p>The reverse of clj-struct-&gt;idx. Returns an object for the given index found in clj-struct-holder.</p></div></div></div><div class="public anchor" id="var-create-map-entry"><h3>create-map-entry</h3><div class="usage"><code>(create-map-entry k v)</code></div><div class="doc"><div class="markdown"><p>Helper to create map entries. This can be useful for serialization implementations on clojure.lang.MapEntry types. Using the ctor instead of clojure.lang.MapEntry/create since this method doesn’t exist prior to clj 1.8.0</p></div></div></div><div class="public anchor" id="var-deserialize-rulebase"><h3>deserialize-rulebase</h3><div class="usage"><code>(deserialize-rulebase session-serializer)</code><code>(deserialize-rulebase session-serializer opts)</code></div><div class="doc"><div class="markdown"><p>Inputs: ([session-serializer :- (s/protocol ISessionSerializer)] [session-serializer :- (s/protocol ISessionSerializer) opts :- {s/Any s/Any}]) Returns: Rulebase</p>
<p>Deserializes the rulebase stored via the serialize-rulebase function. This is done via the given  session-serializer implementor of ISessionSerializer.</p>
<p>Options can be given as an optional argument. These are passed through to the session-serializer  implementation. See the description of standard options an ISessionSerializer should provide in  the ISessionSerializer docs. Also, see the specific ISessionSerializer implementation docs for  any non-standard options supported/not supported.  See ISessionSerializer docs for more on that.</p></div></div></div><div class="public anchor" id="var-deserialize-session-state"><h3>deserialize-session-state</h3><div class="usage"><code>(deserialize-session-state session-serializer memory-facts-serializer)</code><code>(deserialize-session-state session-serializer memory-facts-serializer opts)</code></div><div class="doc"><div class="markdown"><p>Inputs: ([session-serializer :- (s/protocol ISessionSerializer) memory-facts-serializer :- (s/protocol IWorkingMemorySerializer)] [session-serializer :- (s/protocol ISessionSerializer) memory-facts-serializer :- (s/protocol IWorkingMemorySerializer) opts :- {s/Any s/Any}]) Returns: (s/protocol eng/ISession)</p>
<p>Deserializes the session that was stored via the serialize-session-state function. Similar to  what is described there, this uses the session-serializer implementor of ISessionSerializer to  deserialize the session and working memory state. The memory-facts-serializer implementor of  IWorkingMemorySerializer is used to deserialize the actual facts stored in working memory.</p>
<p>Options can be given as an optional argument. These are passed through to the session-serializer  implementation. See the description of standard options an ISessionSerializer should provide in  the ISessionSerializer docs. Also, see the specific ISessionSerializer implementation docs for  any non-standard options supported/not supported.</p></div></div></div><div class="public anchor" id="var-find-index"><h3>find-index</h3><div class="usage"><code>(find-index fact-&gt;idx-map fact)</code></div><div class="doc"><div class="markdown"><p>Finds the fact in the fact-&gt;idx-map. The fact is assumed to be a key. Returns the value for that key, which should just be a numeric index used to track where facts are stubbed out with MemIdx’s in working memory so that they can be ‘put back’ later.</p></div></div></div><div class="public anchor" id="var-find-internal-idx"><h3>find-internal-idx</h3><div class="usage"><code>(find-internal-idx idx)</code></div><div class="doc"><div class="markdown"><p>Finds the fact from mem-internal at the given index. See docs on mem-internal for more.</p></div></div></div><div class="public anchor" id="var-find-mem-idx"><h3>find-mem-idx</h3><div class="usage"><code>(find-mem-idx idx)</code></div><div class="doc"><div class="markdown"><p>Finds the fact from mem-facts at the given index. See docs on mem-facts for more.</p></div></div></div><div class="public anchor" id="var-index-accum-memory"><h3>index-accum-memory</h3><div class="usage"><code>(index-accum-memory seen accum-mem)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-index-activation-map"><h3>index-activation-map</h3><div class="usage"><code>(index-activation-map internal-seen seen actmap)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-index-alpha-memory"><h3>index-alpha-memory</h3><div class="usage"><code>(index-alpha-memory internal-seen seen amem)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-index-beta-memory"><h3>index-beta-memory</h3><div class="usage"><code>(index-beta-memory internal-seen seen bmem)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-index-production-memory"><h3>index-production-memory</h3><div class="usage"><code>(index-production-memory internal-seen seen pmem)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-indexed-session-memory-state"><h3>indexed-session-memory-state</h3><div class="usage"><code>(indexed-session-memory-state memory)</code></div><div class="doc"><div class="markdown"><p>Takes the working memory from a session and strips it down to only the memory needed for serialization. Along with this, replaces all working memory facts with MemIdx place holders. The terminology being used here is to call this step ‘indexing’ the memory. </p>
<p>A map is returned with two keys: * :memory - The working memory representation that is the same as the given memory’s :memory,  however, all facts in the memory are replaced with MemIdx placeholders. * :indexed-facts - the facts replaced with MemIdx placeholders. The facts are returned in a  sequential collection. Each fact is the n’th item of the collection if the MemIdx for that  fact has :idx = n. No facts returned should be identical? (i.e. multiple references to the  same object instance). However, it is possible for some facts returned to be aggregations  containing other facts that do appear elsewhere in the fact sequence. It is up to the  implementation of the IWorkingMemorySerializer to deal with these possible, identical? object  references correctly. This is generally true for most serialization mechanisms.</p>
<p>Note! This function should not typically be used. It is left public to assist in ISessionSerializer  durability implementations. Use clara.rules/mk-session typically to make rule sessions.</p>
<p>Note! Currently this only supports the clara.rules.memory.PersistentLocalMemory implementation  of memory.</p></div></div></div><div class="public anchor" id="var-ISessionSerializer"><h3>ISessionSerializer</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Provides the ability to serialize and deserialize a session. Options can be given and supported via the opts argument to both serialize and deserialize. Certain options are expected and required to be supported by any implementation of ISessionSerializer. These are referred to as the ‘standard’ options. </p>
<p>These include:</p>
<ul>
  <li>
  <p>:rulebase-only? - When true indicates the rulebase is the only part of the session to serializer.  The <em>default</em> is false for the serialize-session-state function. It is defaulted to true for the  serialize-rulebase convenience function. This is useful for when many sessions are to be  serialized, but all having a common rulebase. Storing the rulebase only, will likely save both  space and time in these scenarios.</p></li>
  <li>
  <p>:with-rulebase? - When true the rulebase is included in the serialized state of the session.<br /> The <em>default</em> behavior is false when serializing a session via the serialize-session-state function.</p></li>
  <li>
  <p>:base-rulebase - A rulebase to attach to the session being deserialized. The assumption here is that  the session was serialized without the rulebase, i.e. :with-rulebase? = false, so it needs a rulebase  to be ‘attached’ back onto it to be usable.</p></li>
  <li>
  <p>:forms-per-eval - The maximum number of expressions that will be evaluated per call to eval.  Larger batch sizes should see better performance compared to smaller batch sizes.  Defaults to 5000, see clara.rules.compiler/forms-per-eval-default for more information.</p></li>
</ul>
<p>Options for the rulebase semantics that are documented at clara.rules/mk-session include:</p>
<ul>
  <li>:fact-type-fn</li>
  <li>:ancestors-fn</li>
  <li>:activation-group-sort-fn</li>
  <li>:activation-group-fn</li>
</ul>
<p>Other options can be supported by specific implementors of ISessionSerializer.</p></div></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-deserialize"><h3>deserialize</h3><div class="usage"><code>(deserialize this mem-facts opts)</code></div><div class="doc"><div class="markdown"><p>Deserialize the session state associated to this instance e.g. it may be coming from a known reference to an IO stream. mem-facts is a sequential collection of the working memory facts that were serialized and deserialized by an implementation of IWorkingMemorySerializer.</p></div></div></div><div class="public anchor" id="var-serialize"><h3>serialize</h3><div class="usage"><code>(serialize this session opts)</code></div><div class="doc"><div class="markdown"><p>Serialize the given session with the given options. Where the session state is stored is dependent on the implementation of this instance e.g. it may store it in a known reference to an IO stream.</p></div></div></div></div></div></div><div class="public anchor" id="var-IWorkingMemorySerializer"><h3>IWorkingMemorySerializer</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Provides the ability to serialize and deserialize the facts stored in the working memory of a session. Facts can be serialized in whatever way makes sense for a given domain. The domain of facts can vary greatly from one use-case of the rules engine to the next. So the mechanism of serializing the facts in memory can vary greatly as a result of this. Clara does not yet provide any default implementations for this, but may in the future. However, many of the handlers defined in clara.rules.durability.fressian can be reused if the consumer wishes to serialize via Fressian. See more on this in the clara.rules.durability.fressian namespace docs.</p>
<p>The important part of this serialization protocol is that the facts returned from deserialize-facts are in the <em>same order</em> as how they were given to serialize-facts.</p></div></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-deserialize-facts"><h3>deserialize-facts</h3><div class="usage"><code>(deserialize-facts this)</code></div><div class="doc"><div class="markdown"><p>Returns the facts associated to this instance deserialized in the same order that they were given to serialize-facts.</p></div></div></div><div class="public anchor" id="var-serialize-facts"><h3>serialize-facts</h3><div class="usage"><code>(serialize-facts this fact-seq)</code></div><div class="doc"><div class="markdown"><p>Serialize the given fact-seq, which is an order sequence of facts from working memory of a session.<br />Note, as mentioned in the protocol docs, the <em>order</em> these are given is <em>important</em> and should be preserved when they are returned via deserialize-facts.</p></div></div></div></div></div></div><div class="public anchor" id="var-mem-facts"><h3>mem-facts</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Useful for ISessionSerializer implementors to have a reference to the facts deserialized via IWorkingMemorySerializer that are needed to restore working memory whose locations were stubbed with a MemIdx during serialization.</p></div></div></div><div class="public anchor" id="var-mem-internal"><h3>mem-internal</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Useful for ISessionSerializer implementors to have a reference to the facts deserialized via IWorkingMemorySerializer that are needed to restore working memory whose locations were stubbed with a InternalMemIdx during serialization. These objects are specific to the Clare engine, and as such will be serialized and deserialized along with the memory.</p></div></div></div><div class="public anchor" id="var-node-fn-cache"><h3>node-fn-cache</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A cache for holding the fns used to reconstruct the nodes. Only applicable during read time, specifically this will be bound to a Map of [<node-id> <field-name>] to IFn before the rulebase is deserialized. While the rulebase is deserialized the nodes will reference this cache to repopulate their fns.</field-name></node-id></p></div></div></div><div class="public anchor" id="var-node-id-.3Enode"><h3>node-id-&gt;node</h3><div class="usage"><code>(node-id-&gt;node node-id)</code></div><div class="doc"><div class="markdown"><p>Lookup the node for the given node-id in the node-id-&gt;node-cache cache.</p></div></div></div><div class="public anchor" id="var-node-id-.3Enode-cache"><h3>node-id-&gt;node-cache</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Useful for caching rulebase network nodes by id during serialization and deserialization to avoid creating multiple object instances for the same node.</p></div></div></div><div class="public anchor" id="var-opts-.3Eget-alphas-fn"><h3>opts-&gt;get-alphas-fn</h3><div class="usage"><code>(opts-&gt;get-alphas-fn rulebase opts)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-rulebase-.3Erulebase-with-opts"><h3>rulebase-&gt;rulebase-with-opts</h3><div class="usage"><code>(rulebase-&gt;rulebase-with-opts without-opts-rulebase opts)</code></div><div class="doc"><div class="markdown"><p>Intended for use in rulebase deserialization implementations where these functions were stripped off the rulebase implementation; this function takes these options and wraps them in the same manner as clara.rules/mk-session. This function should typically only be used when implementing ISessionSerializer.</p></div></div></div><div class="public anchor" id="var-seq-.3Esorted-map"><h3>seq-&gt;sorted-map</h3><div class="usage"><code>(seq-&gt;sorted-map s c)</code></div><div class="doc"><div class="markdown"><p>Helper to create a sorted map from a seq given an optional comparator.</p></div></div></div><div class="public anchor" id="var-seq-.3Esorted-set"><h3>seq-&gt;sorted-set</h3><div class="usage"><code>(seq-&gt;sorted-set s c)</code></div><div class="doc"><div class="markdown"><p>Helper to create a sorted set from a seq given an optional comparator.</p></div></div></div><div class="public anchor" id="var-serialize-rulebase"><h3>serialize-rulebase</h3><div class="usage"><code>(serialize-rulebase session session-serializer)</code><code>(serialize-rulebase session session-serializer opts)</code></div><div class="doc"><div class="markdown"><p>Inputs: ([session :- (s/protocol eng/ISession) session-serializer :- (s/protocol ISessionSerializer)] [session :- (s/protocol eng/ISession) session-serializer :- (s/protocol ISessionSerializer) opts :- {s/Any s/Any}])</p>
<p>Serialize <em>only</em> the rulebase portion of the given session. The serialization is done by the  given session-serializer implementor of ISessionSerializer. </p>
<p>Options can be given as an optional argument. These are passed through to the session-serializer  implementation. See the description of standard options an ISessionSerializer should provide in  the ISessionSerializer docs. Also, see the specific ISessionSerializer implementation docs for  any non-standard options supported/not supported.  See ISessionSerializer docs for more on that.</p>
<p>The rulebase is the stateless structure that controls the flow of productions, i.e. the ‘rete’  rule network. The ability to serialize only the rulebase is supported so that the rulebase can  be stored and retrieved a single time for potentially many sessions containing different working  memory data, for the same rules. This function is only a convenience for passing the  :rulebase-only? true flag to the serialize-session-state function.  See serialize-session-state for more.</p></div></div></div><div class="public anchor" id="var-serialize-session-state"><h3>serialize-session-state</h3><div class="usage"><code>(serialize-session-state session session-serializer memory-facts-serializer)</code><code>(serialize-session-state session session-serializer memory-facts-serializer opts)</code></div><div class="doc"><div class="markdown"><p>Inputs: ([session :- (s/protocol eng/ISession) session-serializer :- (s/protocol ISessionSerializer) memory-facts-serializer :- (s/protocol IWorkingMemorySerializer)] [session :- (s/protocol eng/ISession) session-serializer :- (s/protocol ISessionSerializer) memory-facts-serializer :- (s/protocol IWorkingMemorySerializer) opts :- {s/Any s/Any}])</p>
<p>Serializes the state of the given session. By default, this <em>excludes</em> the rulebase from being  serialized alongside the working memory state of the session. The rulebase, if specified, and  the working memory of the session are serialized by the session-serializer implementor of  ISessionSerializer. The memory-serializer implementor of IWorkingMemorySerializer is used to  serialize the actual facts stored within working memory. </p>
<p>Typically, the caller can use a pre-defined default session-serializer, such as  clara.rules.durability.fressian/create-session-serializer.<br /> See clara.rules.durability.fressian for more specific details regarding this, including the extra  required dependency on Fressian notes found there.  The memory-facts-serializer is often a custom provided implemenation since the facts stored in  working memory are domain specific to the consumers’ usage of the rules.  See the IWorkingMemorySerializer docs for more.</p>
<p>Options can be given as an optional argument. These are passed through to the session-serializer  implementation. See the description of standard options an ISessionSerializer should provide in  the ISessionSerializer docs. Also, see the specific ISessionSerializer implementation docs for  any non-standard options supported/not supported.</p></div></div></div><div class="public anchor" id="var-sorted-comparator-name"><h3>sorted-comparator-name</h3><div class="usage"><code>(sorted-comparator-name s)</code></div><div class="doc"><div class="markdown"><p>Sorted collections are not easily serializable since they have an opaque function object instance associated with them. To deal with that, the sorted collection can provide a ::comparator-name in the metadata that indicates a symbolic name for the function used as the comparator. With this name the function can be looked up and associated to the sorted collection again during deserialization time. * If the sorted collection has metadata ::comparator-name, then the value should be a name symbol and is returned.<br />* If the sorted collection has the clojure.lang.RT/DEFAULT_COMPARATOR, returns nil. * If neither of the above are true, an exception is thrown indicating that there is no way to provide a useful name for this sorted collection, so it won’t be able to be serialized.</p></div></div></div></div></body></html>