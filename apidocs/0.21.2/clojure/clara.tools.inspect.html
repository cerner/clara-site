<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>clara.tools.inspect documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Clara-rules</span> <span class="project-version">0.21.2</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clara</span></div></div></li><li class="depth-2"><a href="clara.rules.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rules</span></div></a></li><li class="depth-3 branch"><a href="clara.rules.accumulators.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>accumulators</span></div></a></li><li class="depth-3 branch"><a href="clara.rules.dsl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dsl</span></div></a></li><li class="depth-3 branch"><a href="clara.rules.durability.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>durability</span></div></a></li><li class="depth-3"><a href="clara.rules.listener.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>listener</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>tools</span></div></div></li><li class="depth-3 branch"><a href="clara.tools.fact-graph.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fact-graph</span></div></a></li><li class="depth-3 branch current"><a href="clara.tools.inspect.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>inspect</span></div></a></li><li class="depth-3"><a href="clara.tools.tracing.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tracing</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="clara.tools.inspect.html#var-ConditionMatch"><div class="inner"><span>ConditionMatch</span></div></a></li><li class="depth-1"><a href="clara.tools.inspect.html#var-explain-activations"><div class="inner"><span>explain-activations</span></div></a></li><li class="depth-1"><a href="clara.tools.inspect.html#var-inspect"><div class="inner"><span>inspect</span></div></a></li><li class="depth-1"><a href="clara.tools.inspect.html#var-InspectionSchema"><div class="inner"><span>InspectionSchema</span></div></a></li><li class="depth-1"><a href="clara.tools.inspect.html#var-node-fn-name-.3Eproduction-name"><div class="inner"><span>node-fn-name-&gt;production-name</span></div></a></li><li class="depth-1"><a href="clara.tools.inspect.html#var-strict-map-.3EExplanation"><div class="inner"><span>strict-map-&gt;Explanation</span></div></a></li><li class="depth-1"><a href="clara.tools.inspect.html#var-with-full-logging"><div class="inner"><span>with-full-logging</span></div></a></li><li class="depth-1"><a href="clara.tools.inspect.html#var-without-full-logging"><div class="inner"><span>without-full-logging</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">clara.tools.inspect</h1><div class="doc"><div class="markdown"><p>Tooling to inspect a rule session. The two major methods here are:</p>
<ul>
<li>inspect, which returns a data structure describing the session that can be used by tooling.</li>
<li>explain-activations, which uses inspect and prints a human-readable description covering why each rule activation or query match occurred.</li>
</ul>
</div></div><div class="public anchor" id="var-ConditionMatch"><h3>ConditionMatch</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A structure associating a condition with the facts that matched them.  The fields are: :fact - A fact propagated from this condition in a rule or query.  For non-accumulator conditions, this will be the fact matched by the condition.  For accumulator conditions, it will be the result of the accumulation.  So, for example, if we have a condition like</p>
<pre><code>    [?cold &lt;- Cold]

    a ConditionMatch for this condition will have a Cold fact in its :fact field.  If we have a condition like

    [?min-cold &lt;- (acc/min :temperature) :from [Cold]]

    the value of :fact will be the minimum temperature returned by the accumulator.
</code></pre>
<p>:condition - A structure representing this condition.  This is the same structure used inside the structures defining rules and queries.</p>
<p>:facts-accumulated (nullable) : When the condition is an accumulator condition, this will contain the individual facts over which the accumulator ran.  For example, in the case above with the condition</p>
<pre><code>                             [?min-cold &lt;- (acc/min :temperature) :from [Cold]]
                             
                             this will contain the individual Cold facts over which we accumulated, while the :fact field
                             will contain the result of the accumulation.
</code></pre>
</div></div></div><div class="public anchor" id="var-explain-activations"><h3>explain-activations</h3><div class="usage"><code>(explain-activations session &amp; {:keys [rule-filter-fn], :as options})</code></div><div class="doc"><div class="markdown"><p>Prints a human-friendly explanation of why rules and queries matched in the given session. A caller my optionally pass a :rule-filter-fn, which is a predicate</p>
<p>(clara.tools.inspect/explain-activations session :rule-filter-fn (fn <a href="rule">rule</a>(re-find my-rule-regex (:name rule))))</p>
</div></div></div><div class="public anchor" id="var-inspect"><h3>inspect</h3><div class="usage"><code>(inspect session)</code></div><div class="doc"><div class="markdown"><p>Inputs: <a href="session">session</a></p>
<p>Returns a representation of the given rule session useful to understand the state of the underlying rules.</p>
<p>The returned structure always includes the following keys:</p>
<ul>
<li>:rule-matches – a map of rule structures to their matching explanations. Note that this only includes rule matches with corresponding logical insertions after the rules finished firing.</li>
<li>:query-matches – a map of query structures to their matching explanations.</li>
<li>:condition-matches – a map of conditions pulled from each rule to facts they match.</li>
<li>:insertions – a map of rules to a sequence of {:explanation E, :fact F} records to allow inspection of why a given fact was inserted.</li>
<li>:fact-&gt;explanations – a map of facts inserted to a sequence of maps of the form {:rule rule-structure :explanation explanation}, where each such map justifies a single insertion of the fact.</li>
</ul>
<p>And additionally includes the following keys for operations performed after a with-full-logging call on the session:</p>
<ul>
<li>:unfiltered-rule-matches: A map of rule structures to their matching explanations. This includes all rule activations, regardless of whether they led to insertions or if they were ultimately retracted.  This should be considered low-level information primarily useful for debugging purposes rather than application control logic, although legitimate use-cases for the latter do exist if care is taken.  Patterns of insertion and retraction prior to returning to the caller are internal implementation details of Clara unless explicitly controlled by the user.</li>
</ul>
<p>Users may inspect the entire structure for troubleshooting or explore it for specific cases. For instance, the following code snippet could look at all matches for some example rule:</p>
<p>(defrule example-rule … )</p>
<p>…</p>
<p>(get-in (inspect example-session) <a href=":rule-matches example-rule">:rule-matches example-rule</a>)</p>
<p>…</p>
<p>The above segment will return matches for the rule in question.</p>
</div></div></div><div class="public anchor" id="var-InspectionSchema"><h3>InspectionSchema</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-node-fn-name-.3Eproduction-name"><h3>node-fn-name-&gt;production-name</h3><div class="usage"><code>(node-fn-name-&gt;production-name session node-fn)</code></div><div class="doc"><div class="markdown"><p>A helper function for retrieving the name or names of rules that a generated function belongs to.</p>
<p>‘session’ - a LocalSession from which a function was retrieved ‘node-fn’ - supports the following types: 1. String   - expected to be in the format ‘<namespace>/<node abbreviation=""><em><nodeid></nodeid></em><function abbreviation="">’. Expected use-case for string would be in the event that a user copy pasted this function identifier from an external tool, ex. a jvm profiler 2. Symbol   - expected to be in the format ’<namespace>/<node abbreviation=""><em><nodeid></nodeid></em><function abbreviation="">. Has the same use-case as string, just adds flexibility to the type. 3. Function - expected to be the actual function from the Session This covers a use-case where the user can capture the function being used and programmatically trace it back to the rules being executed.</function></node></namespace></function></node></namespace></p>
</div></div></div><div class="public anchor" id="var-strict-map-.3EExplanation"><h3>strict-map-&gt;Explanation</h3><div class="usage"><code>(strict-map-&gt;Explanation m13242 &amp; [drop-extra-keys?__3254__auto__])</code></div><div class="doc"><div class="markdown"><p>Factory function for class Explanation, taking a map of keywords to field values.  All keys are required, and no extra keys are allowed.  Even faster than map-&gt;</p>
</div></div></div><div class="public anchor" id="var-with-full-logging"><h3>with-full-logging</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Return a new session on which information will be gathered for optional inspection keys. This can significantly increase memory consumption since retracted facts cannot be garbage collected as normally.</p>
</div></div></div><div class="public anchor" id="var-without-full-logging"><h3>without-full-logging</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Return a new session without information gathering on this session for optional inspection keys. This new session will not retain references to any such information previously gathered.</p>
</div></div></div></div></body></html>